
#### CLASS LANDPARAMS

# from RS 'Land' file
# can take one of two forms: 'ArtificialLandscape' or 'ImportedLandscape'

LandParams <- setClass("LandParams", slots = c(LandNum = "integer_OR_numeric")
                                    , prototype = list(LandNum = 1L)
                        )
    # landscape number must be unique

setValidity("LandParams", function(object) {
    msg <- NULL
    if (is.na(object@LandNum) || length(object@LandNum)==0) {
        msg <- c(msg, "LandNum must be set!")
    }
    else {
        if (object@LandNum < 1) {
            msg <- c(msg, "Landscape number must be positive.")
        }
    }
    if (is.null(msg)) TRUE else msg}
)
setMethod("initialize", "LandParams", function(.Object, ...) {
    .Object <- callNextMethod()
    .Object}
)



### CLASS ARTIFICIALLANDSCAPE

#' Create an Artificial Landscape
#'
#' An artificial landscape can be generated with a random or fractal spatial structure, and may be using binary or continuous habitat values to characterise each cell.
#'
#' @author Anne-Kathleen Malchow
#' @usage ArtificialLandscape(propSuit = 0.5, K = 10, Resolution = 100, dimX = 65, dimY = 65,
#'                     fractal = FALSE, hurst, continuous = FALSE, minPct, maxPct)
#' @param propSuit Proportion of suitable habitat cells, defaults to \eqn{0.5}.
#' @param K Carrying capacity of habitat cells in units of number of individuals per hectare. Defaults to \eqn{10}. (integer)
#' If combined with a \code{\link[RangeshiftR]{StageStructure}}d model, \code{K} will be used to calculate the \emph{strength of density dependence} \ifelse{html}{\out{b=K<sup>-1</sup>}}{\eqn{b=1/K}}
#' instead of interpreting it as limiting carrying capacity.\cr
#' @param Resolution Cell size in meters, defaults to \eqn{100}. (integer)
#' @param dimX,dimY Number of cells along the x- and y-axis, both default to \eqn{65}. (integer) \cr
#' If \code{fractal=TRUE}, \code{dimX} and \code{dimY} must be powers of \eqn{2} plus \eqn{1} (\eqn{2^n+1}) and \code{dimX} \eqn{\le} \code{dimY} .
#' @param fractal If \code{FALSE} (default), a random landscape is generated. Each cell has a certain probability of being a habitat.\cr
#' If \code{TRUE}, a fractal landscape is generated. These landscapes contain a greater structure than random landscapes but less than a completely deterministic one.
#' @param hurst Required if \code{fractal=TRUE}: Hurst exponent. Can be any number in the open interval \eqn{(0,1)}.
#' @param continuous Use continuous or binary habitat values to describe each cell?\cr If \code{FALSE} (default), the resulting landscape
#' is binary, with the two values \emph{Habitat} and \emph{Matrix} (i.e. Non-habitat).\cr If \code{TRUE}, each cell is given a continuous value which describes the percentage of habitat cover
#' within a cell. The carrying capacity of that cell is calculated as the respective fraction of the value of \eqn{K}.
#' @param minPct,maxPct Required if \code{continuous=TRUE}: Minimum and Maximum percentage of habitat cover within a cell. Can be any number in the open interval \eqn{(0,1)},
#' \code{maxPct} may be exactly \eqn{1}. \code{minPct} must be smaller than \code{maxPct}.
#' @details The fractal landscape generator uses the midpoint displacemeant algorithm. The Hurst exponent, often referred to as \eqn{H},
#' describes the degree of spatial autocorrelation of the landscape configuration. Values close to \eqn{0} represent a low autocorrelation but
#' the generated landscapes still aren't completely spatially independent. On the contrary, values close to \eqn{1} represent high autocorrelation,
#' i.e. high habitat aggregation.
#' Note that more complex algorithms are available for providing fractals where setting \eqn{H = 0.0} results in no spatial autocorrelation.
#' Futher note that the spatial structure of landscapes fragmented by human activities is often not fractal in nature and, depending upon
#' the research question, other landscape generators may be more appropriate.
#' For applications where the embedded algorithm is not sufficient, we recommend to import landscapes generated by these alternative algorithms.
#' @references Saupe 1988, Chipperfield et al. 2011, With 1997, Pe'er et al. 2013
#' @return A parameter object of class "ArtificialLandscape"
#' @name ArtificialLandscape
#' @export ArtificialLandscape
ArtificialLandscape <- setClass("ArtificialLandscape", slots = c(propSuit = "numeric",
                                                                 K = "integer_OR_numeric",
                                                                 Resolution = "integer_OR_numeric",
                                                                 dimX = "integer_OR_numeric",
                                                                 dimY = "integer_OR_numeric",
                                                                 fractal = "logical",
                                                                 hurst = "numeric",
                                                                 continuous = "logical",
                                                                 minPct = "numeric",
                                                                 maxPct = "numeric")
                           , prototype = list(propSuit = 0.5,
                                              K = 10L,
                                              Resolution = 100L,
                                              dimX = 65L,
                                              dimY = 65L,
                                              fractal = FALSE,
                                              #hurst,
                                              continuous = FALSE)
                                              #minPct,
                                              #maxPct,
                           , contains = "LandParams")

setValidity("ArtificialLandscape", function(object) {
    msg <- NULL
    if (is.na(object@propSuit) || length(object@propSuit)==0) {
        msg <- c(msg, "Proportion of suitable habitat must be set!")
    }
    else {
        if (object@propSuit<0 || object@propSuit>1) {
            msg <- c(msg, "Proportion of suitable habitat must be in the interval [0,1].")
        }
    }
    if (is.na(object@K) || length(object@K)==0) {
        msg <- c(msg, "Carrying capacity K must be set!")
    }
    else {
        if (object@K<0) {
            msg <- c(msg, "Carrying capacity K must not be smaller than 0.")
        }
    }
    if (is.na(object@Resolution) || length(object@Resolution)==0) {
        msg <- c(msg, "Resolution of landscape must be set!")
    }
    else {
        if (object@Resolution < 1) {
            msg <- c(msg, "Resolution of landscape must be positive.")
        }
    }
    if (is.na(object@dimX) || length(object@dimX)==0) {
        msg <- c(msg, "dimX must be set!")
    }
    if (is.na(object@dimY) || length(object@dimY)==0) {
        msg <- c(msg, "dimY must be set!")
    }
    if (is.na(object@fractal) || length(object@fractal)==0) {
        msg <- c(msg, "fractal must be set!")
    }
    if (is.na(object@continuous) || length(object@continuous)==0) {
        msg <- c(msg, "continuous must be set!")
    }
    if (is.null(msg)) {
        if (object@fractal) {
            if (object@dimX < 3) {
                msg <- c(msg, "Number of cells in any direction must be at least 3 for a fractal landscape.")
            }
            else {
                if (!isPowerOf2(object@dimX-1)) {
                    msg <- c(msg, "Number of cells in any direction must be a power of 2 plus 1 for a fractal landscape.")
                }
            }
            if (object@dimY < 3) {
                msg <- c(msg, "Number of cells in any direction must be at least 3 for a fractal landscape.")
            }
            else {
                if (!isPowerOf2(object@dimY-1)) {
                    msg <- c(msg, "Number of cells in any direction must be a power of 2 plus 1 for a fractal landscape.")
                }
            }
            if (object@dimY < object@dimX) {
                msg <- c(msg, "Y-dimension may not be less than X-dimension for a fractal landscape.")
            }
            if (is.na(object@hurst) || length(object@hurst)==0) {
                msg <- c(msg, "Hurst exponent must be set for a fractal landscape.")
            }
            else {
                if (object@hurst<0 || object@hurst>1) {
                    msg <- c(msg, "Hurst exponent must be in the open interval (0,1).")
                }
                if (object@hurst==0 || object@hurst==1) {
                    msg <- c(msg, "Hurst exponent must be in the open interval (0,1). It can't be exactly 0 or 1.")
                }
            }
        }
        else { # non-fractal landscape
            if (object@dimX < 1) {
                msg <- c(msg, "Number of cells in any direction must be at least 1 for a non-fractal landscape.")
            }
            if (object@dimY < 1) {
                msg <- c(msg, "Number of cells in any direction must be at least 1 for a non-fractal landscape.")
            }
        }
        if(object@continuous) {
            if (is.na(object@minPct) || length(object@minPct)==0) {
                minP.ok = FALSE
                msg <- c(msg, "Minimum habitat percentage must be set for a continuous landscape.")
            }
            else {
                if (object@minPct<=0 || object@minPct>=1) {
                    minP.ok = FALSE
                    msg <- c(msg, "Minimum habitat percentage must be in the open interval (0,1).")
                }
                else {minP.ok = TRUE}
            }
            if (is.na(object@maxPct) || length(object@maxPct)==0) {
                maxP.ok = FALSE
                msg <- c(msg, "Maximum habitat percentage must be set for a continuous landscape.")
            }
            else {
                if (object@maxPct<=0 || object@maxPct>1) {
                    maxP.ok = FALSE
                    msg <- c(msg, "Maximum habitat percentage must be in the half-open interval (0,1].")
                }
                else {maxP.ok = TRUE}
            }
            if (minP.ok && maxP.ok) {
                if (object@maxPct <= object@minPct) {
                    msg <- c(msg, "Maximum habitat percentage may not be less than Minimum habitat percentage.")
                }
            }
        }
    }
    if (is.null(msg)) TRUE else msg}
)
setMethod("initialize", "ArtificialLandscape", function(.Object,...) {
    this_func = "ArtificialLandscape(): "
    args <- list(...)
    .Object <- callNextMethod()
    if ( length(args) == 0 ) {
        validObject(.Object)
    }
    if (!.Object@fractal) {
        .Object@hurst = -9L
        if (!is.null(args$hurst)) {
            warning(this_func, "Hurst exponent", warn_msg_ignored, "for a non-fractal landscape.", call. = FALSE)
       }
    }
    if(!.Object@continuous) {
        .Object@minPct = -9L
        if (!is.null(args$minPct)) {
            warning(this_func, "Minimum habitat percentage", warn_msg_ignored, "for a discrete landscape.", call. = FALSE)
        }
        .Object@maxPct = -9L
        if (!is.null(args$maxPct)) {
            warning(this_func, "Maximum habitat percentage", warn_msg_ignored, "for a discrete landscape.", call. = FALSE)
        }
    }
    .Object}
)
setMethod("show", "ArtificialLandscape", function(object){
    cat(" Artificial landscape: ")
    #cat(" Artificial landscape #", object@LandNum, ": ")
    if(object@fractal) {
        cat("fractal structure, ")
    }
    else {
        cat("random structure, ")
    }
    if(object@continuous) {
        cat("continuous habitat quality\n")
    }
    else {
        cat("binary habitat/matrix code\n")
    }
    cat ("   Size              :", paste(object@dimX), "x", paste(object@dimY), "cells\n")
    cat ("   Resolution        :      ", paste(object@Resolution) , "meters\n")
    cat ("   Proportion of suitable habitat:", object@propSuit,"\n")
    cat ("   Carrying capacity :", object@K,"\n")
    if(object@fractal) {
        cat ("   Hurst exponent    : H =", object@hurst, "\n")
    }
    if(object@continuous) {
        cat ("   Minimum habitat quality: minPct =", object@minPct, "\n")
        cat ("   Maximum habitat quality: maxPct =", object@maxPct, "\n")
    }
})


### CLASS IMPORTEDLANDSCAPE

#' Import a Landscape from file
#'
#' @description Provide the filename (\code{LandscapeFile}), the resolution and, if applicable, the number of habitat codes (\code{Nhabitats})
#' as well as their respective carrying capacities (\code{K}) of the map to be imported.
#'
#' Optionally, a patch-map can be loaded to define habitat patches. A distribution-map can be loaded to define an initial species distribution.
#'
# #' @author Anne-Kathleen Malchow
#' @usage ImportedLandscape(LandscapeFile, Resolution = 100, HabitatQuality = FALSE,
#'                   Nhabitats, K = 10, PatchFile = "NULL",
#'                   SpDistFile = "NULL", SpDistResolution,
#'                   DynamicLand = "NULL")
#' @param LandscapeFile Filename of the landscape habitat map which shall be imported from the Inputs-folder. See the Details for information on the required format.
#' @param Resolution Cell size in meters, defaults to \eqn{100}. (integer)
#' @param HabitatQuality If FALSE (default), unique integer habitat codes are expected in the imported map to characterise the habitat of each cell. This requires to set \code{Nhabitats}. \cr
#' If TRUE, continuous habitat quality values are expected, ranging from \eqn{0.0} to \eqn{100.0}.\cr
#' Make sure your imported landscape file uses the specified standard (see Details below).
#' @param Nhabitats Required if \code{HabitatQuality=FALSE}: Number of habitats in the imported landscape if unique integer habitat codes are used. (integer)
#' @param K Carrying capacity of habitat cells in units of number of individuals per hectare (integer), defaults to \eqn{10}.\cr
#' If combined with a \code{\link[RangeshiftR]{StageStructure}}d model, \code{K} will be used to calculate the \emph{strength of density dependence} \ifelse{html}{\out{b=K<sup>-1</sup>}}{\eqn{b=1/K}}
#' instead of interpreting it as limiting carrying capacity.\cr
#' If \code{HabitatQuality=FALSE}, a vector of length \code{Nhabitats} is expected, specifying the respective carrying capacity for every habitat code.\cr
#' If \code{HabitatQuality=TRUE}, \eqn{K} is interpreted as the maximum carrying capacity reached in cells with \eqn{100}\% habitat quality. All other cells have the respective fraction of \eqn{K}.
#' @param PatchFile Filename of the patch map which shall be imported, Default is \code{NULL}.
#' @param SpDistFile Filename of the species initial distribution map which shall be imported (*.txt). Default is \code{NULL}.
#' @param SpDistResolution Required if \code{SpDistFile} is given: Cell size of the distribution map in meters. (integer) Must be an integer multiple of the landscape resolution.
#' @param DynamicLand Data.frame containing the named colums 'Year', 'ChLand', and - for a patch-based model - 'ChPatch'. Each row defines a change in the landscape.
#' @details RangeShifter requires every input map to be a text file in ArcGIS raster export format, which has the following six header lines:
#' \tabular{ll}{\code{ncols} \tab Number of columns \cr
#' \code{nrows} \tab Number of rows \cr
#' \code{xllcorner} \tab x-coordinate (longitude) of the lower-left corner \cr
#' \code{yllcorner} \tab y-coordinate (latitude) of the lower-left corner \cr
#' \code{cellsize} \tab Resolution (in meters) \cr
#' \code{NODATA_value} \tab Value for cells having missing data (usually -9999) }
#'
#' The rest of the file is a grid containing a value for each cell, one line per row. \code{RangeShiftR} can read-in two different types of habitat maps:
#'  - \emph{Raster with habitat codes} (\code{HabitatQuality=FALSE}):  In this option each habitat or land-cover type has a unique integer code. Each cell in the file contains a single habitat code and \eqn{100} percent coverage is assumed for the cell. The landscape is therefore composed of discrete habitat cells. The codes are required to be sequential integers starting from \eqn{1} and ranging to \code{Nhabitats}.
#'  - \emph{Raster with habitat quality} (\code{HabitatQuality=TRUE}): Each cell in the landscape is assigned a continuous quality value between \eqn{0.0} and \eqn{100.0}. There are no explicit habitat or land-cover types. This allows integrating different methods for calculating the habitat suitability for a given species. For example, qualities can result from different methods of suitability modelling, which incorporate multiple variables like habitat types, elevation, climate, etc. In the current version of the program, a straight-line relationship between carrying capacity and quality is assumed. Therefore, the quality should be scaled accordingly in case of a curvilinear relationship.
#'
#' The simulation can be run as a \emph{patch-based model} on the same habitat map described above. An additional file must be provided through \code{PatchFile}: a raster map of the same landscape, where
#' each cell contains the ID number of the patch to which it belongs. Each patch must have a unique positive integer ID. The ID of every cell that does not belong to a patch (i.e. non-habitat/matrix) must be zero.
#' Note that a single patch is the unit at which the density dependence in the population dynamics acts. Therefore, a patch can be discontinuous, i.e. it can contain cells that do not belong to the patch if they
#' are assumed not to affect the dynamics, or on the other hand, patch cells that are not physically contiguous to the rest of the patch cells.
#'
#' A \emph{species distribution map} can be overlaid on top of the habitat map and can be used to define an initial distribution. The map is provided through \code{SpDistFile} must be in raster format and be aligned with the landscape map, i.e. the coordinates of the lower-left corner must be the same. The extent of the map does not have to be necessarily
#' the same as the landscape. The resolution can be the same or coarser, provided that it is a multiple of the landscape resolution. For example, if the landscape cell size is \eqn{250m}, the species distribution can be at the resolution of \eqn{250m}, \eqn{500m}, \eqn{750m}, \eqn{1000m} etc.
#' Each cell of the species distribution map must contain either \eqn{0} (species absent or not recorded) or \eqn{1} (species present).
#' @return A parameter object of class ImportedLandscape
#' @name ImportedLandscape
#' @export ImportedLandscape
ImportedLandscape <- setClass("ImportedLandscape", slots = c(LandscapeFile = "character",
                                                             Resolution = "integer_OR_numeric",
                                                             HabitatQuality = "logical",
                                                             Nhabitats = "integer_OR_numeric", # not used in RS anymore. In R is used to define maxNhab in ControlParams
                                                             K = "integer_OR_numeric",
                                                             PatchFile = "character",          # sets the patchmodel -switch in class ControlParams when added
                                                             SpDistFile = "character",         # sets the speciesdist -switch in class ControlParams when added
                                                             SpDistResolution = "integer_OR_numeric",
                                                             DynamicLand = "data.frame")
                              , prototype = list(#LandscapeFile,
                                                 Resolution = 100L,
                                                 HabitatQuality = FALSE,
                                                 #Nhabitats,
                                                 K = 10L,
                                                 PatchFile = "NULL",
                                                 SpDistFile = "NULL",
                                                 #SpDistResolution,
                                                 DynamicLand = data.frame())
                              , contains = "LandParams")

        # add interface and docu for Dynamic Landscapes

setValidity("ImportedLandscape", function(object) {
    msg <- NULL
    if (is.na(object@LandscapeFile) || length(object@LandscapeFile)==0) {
        msg <- c(msg, "No filename to import Landscape from was given.")
    }
    if (is.na(object@Resolution) || length(object@Resolution)==0) {
        msg <- c(msg, "Resolution of landscape must be given!")
    }
    else {
        if (object@Resolution < 1) {
            msg <- c(msg, "Resolution of landscape must be positive.")
        }
    }
    if (is.na(object@HabitatQuality) || length(object@HabitatQuality)==0) {
        msg <- c(msg, "HabitatQuality must be set!")
    }
    if (anyNA(object@K) || length(object@K)==0) {
        msg <- c(msg, "Carrying capacity K must be set!")
    }
    else {
        if (any(object@K<0)) {
            msg <- c(msg, "Carrying capacity K must not be smaller than 0 for any habitat type.")
        }
    }
    if (!object@HabitatQuality) {
        if (is.na(object@Nhabitats) || length(object@Nhabitats)==0) {
            msg <- c(msg, "Number of habitat codes must be given for the imported landscape. If your landscape is specified by habitat quality, please set \"HabitatQuality = TRUE\". ")
        }
        else {
            if (object@Nhabitats < 2){
                msg <- c(msg, "Number of habitat codes must be at least 2 when habitat codes are used.")
            }
        }
    }
    if (is.null(msg)) {
        if (object@HabitatQuality) {
            if (length(object@K) != 1) {
                msg <- c(msg, "Carrying capacity K must be of length 1, specifying the maximum carrying capacity for 100% habitat.")
            }
        }
        else {
            if (length(object@K) != object@Nhabitats) {
                msg <- c(msg, "Carrying capacity K must be a vector of length 'Nhabitats', specifying the respective carrying capacity for every habitat code.")
            }
        }
    }
    if (object@SpDistFile!="NULL") {
        if (is.na(object@SpDistResolution) || length(object@SpDistResolution)==0) {
            msg <- c(msg, "Resolution of Species distribution must be set!")
        }
        else {
            if (object@SpDistResolution < 1) {
                msg <- c(msg, "Resolution of landscape must be positive.")
            }
            else {
                if (object@SpDistResolution < object@Resolution) {
                    msg <- c(msg, "Resolution of Species distribution may not be less than Landscape Resolution.")
                }
                else {
                    if (object@SpDistResolution %% object@Resolution) {
                        msg <- c(msg, "SpDistResolution must be an integer multiple of Resolution.")
                    }
                }
            }
        }
    }
    if (length(object@DynamicLand)>0) {
        if (anyNA(object@DynamicLand)) {
            msg <- c(msg, "All entries in DynamicLand must be set!")
        }
        else{
            if(PatchFile == "NULL"){
                if(!all(names(object@DynamicLand)==c("Year","ChLand"))){
                    msg <- c(msg, "DynamicLand must have the named clomuns 'Year','ChLand' for a cell-based landscape!")
                }
            }
            else{
                if(!all(names(object@DynamicLand)==c("Year","ChLand","ChPatch"))){
                    msg <- c(msg, "DynamicLand must have the named clomuns 'Year','ChLand','ChPatch' for a patch-based landscape!")
                }
            }
        }
    }
    if (is.null(msg)) TRUE else msg}
)
setMethod("initialize", "ImportedLandscape", function(.Object, ...) {
    this_func = "ImportedLandscape(): "
    args <- list(...)
    .Object <- callNextMethod()
    if ( length(args) == 0 ) {
        validObject(.Object)
    }
    if (.Object@HabitatQuality) {
        .Object@Nhabitats = 1L
        if (!is.null(args$Nhabitats)) {
            warning(this_func, "Nhabitats", warn_msg_ignored, "for continuous habitat quality landscape.", call. = FALSE)
        }
    }
    if (.Object@SpDistFile=="NULL") {
        .Object@SpDistResolution = -9
        if (!is.null(args$SpDistResolution)) {
            warning(this_func, "Resolution of Species distribution", warn_msg_ignored, "since no map file is given.", call. = FALSE)
        }
    }
    .Object}
)
setMethod("show", "ImportedLandscape", function(object){
    cat(" Landscape imported from file:\n  ", paste(object@LandscapeFile), "\n")
    #cat(" Landscapee #", object@LandNum, "imported from file:\n  ", paste(object@LandscapeFile), "\n")
    if(object@HabitatQuality) {
        cat("   with continuous habitat quality\n")
        cat("   Maximum carrying capacity K =", paste(object@K), ".\n")
    }
    else {
        cat("   with", paste(object@Nhabitats), "unique integer habitat code(s)\n")
        cat("   Carrying capacities K =", paste(object@K), ".\n")
    }
    if (object@PatchFile!="NULL") {
        cat("   Patches imported from file:\n  ", paste(object@PatchFile), "\n")
    }
    cat ("   Resolution      :", paste(object@Resolution),"\n")
    #if (object@DynLandFile!="NULL") {
    #    cat(" Dynamic landscape imported from file:\n  ", paste(object@DynLandFile), "\n")
    #}
    if(object@SpDistFile!="NULL") {
        cat(" Initial Species Distribution imported from file:\n  ", paste(object@SpDistFile), "\n")
        cat ("   Resolution      :", paste(object@SpDistResolution),"\n")
    }
    #cat ("\n")
    }
)


### Helper functions

## Check if a number is a power of 2
isPowerOf2 <- function(x) {
    n1s <- sum(as.numeric(intToBits(x)))
    if (n1s == 1) {
        return(TRUE)
    } else {
        return(FALSE)
    }
}

# RS manual 3.1.1 (page 51) - 3.1.2 (page 54)
